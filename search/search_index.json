{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Red Hat OpenShift Serverless \u00b6 Red Hat OpenShift Serverless can be used to build, deploy and run event-driven applications that will start based on an event trigger, scale up resources as needed, then scale to zero after resource burst. These hands on exercises utilize OpenShift Serverless to create serverless workloads on OpenShift. Pre-requisites \u00b6 a Free IBM Cloud account, to create a new IBM Cloud account, follow the instructions here . a Red Hat OpenShift Kubernetes Service (ROKS) v4.5 using a cluster with admin rights and with the knative-serving operator installed. Labs \u00b6 Setup , Deploy our First Application to Knative using the Knative Client (kn) , Deploy vnext Version and Apply Traffic Shifting , Tag revisions to generate custom app URLs , Knative from the Kubernetes Layer Technologies \u00b6 Red Hat OpenShift Kubernetes Service (ROKS) v4.5 Red Hat OpenShift Serverless components Contributors \u00b6 Belinda Venman, beemarie David Carew, djccarew","title":"About the labs"},{"location":"#red-hat-openshift-serverless","text":"Red Hat OpenShift Serverless can be used to build, deploy and run event-driven applications that will start based on an event trigger, scale up resources as needed, then scale to zero after resource burst. These hands on exercises utilize OpenShift Serverless to create serverless workloads on OpenShift.","title":"Red Hat OpenShift Serverless"},{"location":"#pre-requisites","text":"a Free IBM Cloud account, to create a new IBM Cloud account, follow the instructions here . a Red Hat OpenShift Kubernetes Service (ROKS) v4.5 using a cluster with admin rights and with the knative-serving operator installed.","title":"Pre-requisites"},{"location":"#labs","text":"Setup , Deploy our First Application to Knative using the Knative Client (kn) , Deploy vnext Version and Apply Traffic Shifting , Tag revisions to generate custom app URLs , Knative from the Kubernetes Layer","title":"Labs"},{"location":"#technologies","text":"Red Hat OpenShift Kubernetes Service (ROKS) v4.5 Red Hat OpenShift Serverless components","title":"Technologies"},{"location":"#contributors","text":"Belinda Venman, beemarie David Carew, djccarew","title":"Contributors"},{"location":"lab1/","text":"Deploy our First Application to Knative using the Knative Client (kn) \u00b6 The Knative client, kn, aims to make interacting with Knative a seamless experience for developers. In this section we'll try deploying an application using kn. The application for this lab is a simple Node.js with Express app which returns the first n numbers of the Fibonacci sequence. Once the app is deployed, you can use it by making a GET request to the / endpoint with a number as the parameter. Deploy our Application to Knative using kn \u00b6 We've already created an image on dockerhub that contains the first version of our Fibonacci application. If we call the / endpoint, and pass in a number parameter, we should get the first n numbers of the Fibonacci sequence. Deploy the application. We will create a Knative Service named fib-knative which will run our fib-knative image on dockerhub. Run the following command in the IBM Cloud Shell terminal. kn service create fib-knative --image docker.io/ibmcom/fib-knative You should see some output indicating that the service was created. You should also be given the URL where your application will be available. It should look something like http://fib-knative.default.bmv-knative-lab.us-south.containers.appdomain.cloud . Creating service 'fib-knative' in namespace 'default': 0.316s The Route is still working to reflect the latest desired specification. 0.637s Configuration \"fib-knative\" is waiting for a Revision to become ready. 5.305s ... 5.400s Ingress has not yet been reconciled. 6.424s Ready to serve. Service 'fib-knative' created to latest revision 'fib-knative-ywvgm-1' is available at URL: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud You should see your cluster name as a part of the URL, since IBM Cloud Kubernetes Service sets the default domain name for Knative to match the domain name of your cluster. Save this URL as an environment variable, so that we can use it throughout the lab: export MY_APP_URL = <your_application_url_here> Let's take a look at some details about the service we just created using the kn service describe command. kn service describe fib-knative Example Output: Name: fib-knative Namespace: default Age: 11s URL: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Revisions: 100% @latest (fib-knative-lhghx-1) [1] (11s) Image: docker.io/ibmcom/fib-knative (pinned to 9eac25) Conditions: OK TYPE AGE REASON ++ Ready 6s ++ ConfigurationsReady 7s ++ RoutesReady 6s We can see the URL, the name of the service, and some status information about the service. We can also look at the various revisions for this service. Currently, we only have one revision with 100% of the traffic being routed there. Let's try out our application! We can curl the URL to try out our application. Notice that we're calling the / endpoint, and passing in a number parameter of 5. This should return the first 5 numbers of the Fibonacci sequence. curl $MY_APP_URL /5 Expected Output: [1,1,2,3,5] Congratulations! You've got your first Knative application deployed and responding to requests. Try sending some different number requests.","title":"Deploy our First Application to Knative using the Knative Client (kn)"},{"location":"lab1/#deploy-our-first-application-to-knative-using-the-knative-client-kn","text":"The Knative client, kn, aims to make interacting with Knative a seamless experience for developers. In this section we'll try deploying an application using kn. The application for this lab is a simple Node.js with Express app which returns the first n numbers of the Fibonacci sequence. Once the app is deployed, you can use it by making a GET request to the / endpoint with a number as the parameter.","title":"Deploy our First Application to Knative using the Knative Client (kn)"},{"location":"lab1/#deploy-our-application-to-knative-using-kn","text":"We've already created an image on dockerhub that contains the first version of our Fibonacci application. If we call the / endpoint, and pass in a number parameter, we should get the first n numbers of the Fibonacci sequence. Deploy the application. We will create a Knative Service named fib-knative which will run our fib-knative image on dockerhub. Run the following command in the IBM Cloud Shell terminal. kn service create fib-knative --image docker.io/ibmcom/fib-knative You should see some output indicating that the service was created. You should also be given the URL where your application will be available. It should look something like http://fib-knative.default.bmv-knative-lab.us-south.containers.appdomain.cloud . Creating service 'fib-knative' in namespace 'default': 0.316s The Route is still working to reflect the latest desired specification. 0.637s Configuration \"fib-knative\" is waiting for a Revision to become ready. 5.305s ... 5.400s Ingress has not yet been reconciled. 6.424s Ready to serve. Service 'fib-knative' created to latest revision 'fib-knative-ywvgm-1' is available at URL: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud You should see your cluster name as a part of the URL, since IBM Cloud Kubernetes Service sets the default domain name for Knative to match the domain name of your cluster. Save this URL as an environment variable, so that we can use it throughout the lab: export MY_APP_URL = <your_application_url_here> Let's take a look at some details about the service we just created using the kn service describe command. kn service describe fib-knative Example Output: Name: fib-knative Namespace: default Age: 11s URL: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Revisions: 100% @latest (fib-knative-lhghx-1) [1] (11s) Image: docker.io/ibmcom/fib-knative (pinned to 9eac25) Conditions: OK TYPE AGE REASON ++ Ready 6s ++ ConfigurationsReady 7s ++ RoutesReady 6s We can see the URL, the name of the service, and some status information about the service. We can also look at the various revisions for this service. Currently, we only have one revision with 100% of the traffic being routed there. Let's try out our application! We can curl the URL to try out our application. Notice that we're calling the / endpoint, and passing in a number parameter of 5. This should return the first 5 numbers of the Fibonacci sequence. curl $MY_APP_URL /5 Expected Output: [1,1,2,3,5] Congratulations! You've got your first Knative application deployed and responding to requests. Try sending some different number requests.","title":"Deploy our Application to Knative using kn"},{"location":"lab2/","text":"Deploy vnext Version and Apply Traffic Shifting \u00b6 Did you notice that the Fibonacci sequence started with 1? Many would argue that the sequence should actually start with 0. There's a vnext version of the application that starts the sequence with 0 instead of 1. This container image has been built, deployed to dockerhub, and tagged as vnext. We'll deploy that as v2 of our app, and then route a small percentage of the traffic to it. Update First Revision Name \u00b6 When we first deployed our application, we didn't provide a revision name, so Knative assigned a random revision name, something like fib-knative-lhghx-1 . Let's give the service the revision name fib-knative-one since in this version of the application the sequence begins with one. Naming our own revisions can be helpful for readability, but it isn't required. We'll later use this revision name to route traffic between two different revisions. kn service update fib-knative --revision-name fib-knative-one Deploy vnext \u00b6 Let's deploy the next version of our application, where the Fibonacci sequence begins with 0. We will again deploy from a docker image on dockerhub. kn service update fib-knative --image docker.io/ibmcom/fib-knative:vnext --revision-name fib-knative-zero First, notice that this revision is named fib-knative-zero , since the Fibonacci sequence will now start with zero. You can see that we're using the vnext version of our application. Let's see the details for our Service, again using kn service describe kn service describe fib-knative Example output: Name: fib-knative Namespace: default Age: 1m URL: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Revisions: 100% @latest (fib-knative-zero) [2] (9s) Image: docker.io/ibmcom/fib-knative:vnext (pinned to c13569) Conditions: OK TYPE AGE REASON ++ Ready 5s ++ ConfigurationsReady 6s ++ RoutesReady 5s We can see that our latest revision (fib-knative-zero) has 100% of the traffic being routed to it. We can try out the application by curling the URL. We should see that the sequence now starts with zero. curl $MY_APP_URL /5 Expected Output: [0, 1, 1, 2, 3] What if we didn't want 100% of our traffic going to this new revision? Maybe we want to slowly roll users over from our old version to the new version, or do some A/B testing of the new version to see what users prefer. Let's update the service to send 10% of the traffic to our new revision ( fib-knative-zero ), and 90% to the old revision ( fib-knative-one ) kn service update fib-knative --traffic fib-knative-zero = 10 --traffic fib-knative-one = 90 Again, we can use kn service describe to see these changes. Notice the Revisions section. You can see that 10% of the traffic will be sent to fib-knative-zero , and 90% of the traffic will be sent to fib-knative-one . kn service describe fib-knative Expected Output: Revisions: 10% fib-knative-zero (current @latest) [2] (58m) Image: docker.io/ibmcom/fib-knative:vnext (pinned to c13569) 90% fib-knative-one [1] (59m) Image: docker.io/ibmcom/fib-knative (pinned to 9eac25) Let's run some load against the app, just requesting the first number in the Fibonacci sequence so that we can clearly see which revision is being called. while sleep 0 .5 ; do curl \" $MY_APP_URL /1\" ; done Expected Output: [1][1][0][1][1][1][1][1][1][1][1] We should see that the curl requests are routed approximately 90/10 between the two revisions. Let's kill this process using ctrl + c . Congratulations! You've deployed two versions of the fib-knative application, and then updated the rollout percentage of your application.","title":"Deploy vnext Version and Apply Traffic Shifting"},{"location":"lab2/#deploy-vnext-version-and-apply-traffic-shifting","text":"Did you notice that the Fibonacci sequence started with 1? Many would argue that the sequence should actually start with 0. There's a vnext version of the application that starts the sequence with 0 instead of 1. This container image has been built, deployed to dockerhub, and tagged as vnext. We'll deploy that as v2 of our app, and then route a small percentage of the traffic to it.","title":"Deploy vnext Version and Apply Traffic Shifting"},{"location":"lab2/#update-first-revision-name","text":"When we first deployed our application, we didn't provide a revision name, so Knative assigned a random revision name, something like fib-knative-lhghx-1 . Let's give the service the revision name fib-knative-one since in this version of the application the sequence begins with one. Naming our own revisions can be helpful for readability, but it isn't required. We'll later use this revision name to route traffic between two different revisions. kn service update fib-knative --revision-name fib-knative-one","title":"Update First Revision Name"},{"location":"lab2/#deploy-vnext","text":"Let's deploy the next version of our application, where the Fibonacci sequence begins with 0. We will again deploy from a docker image on dockerhub. kn service update fib-knative --image docker.io/ibmcom/fib-knative:vnext --revision-name fib-knative-zero First, notice that this revision is named fib-knative-zero , since the Fibonacci sequence will now start with zero. You can see that we're using the vnext version of our application. Let's see the details for our Service, again using kn service describe kn service describe fib-knative Example output: Name: fib-knative Namespace: default Age: 1m URL: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Revisions: 100% @latest (fib-knative-zero) [2] (9s) Image: docker.io/ibmcom/fib-knative:vnext (pinned to c13569) Conditions: OK TYPE AGE REASON ++ Ready 5s ++ ConfigurationsReady 6s ++ RoutesReady 5s We can see that our latest revision (fib-knative-zero) has 100% of the traffic being routed to it. We can try out the application by curling the URL. We should see that the sequence now starts with zero. curl $MY_APP_URL /5 Expected Output: [0, 1, 1, 2, 3] What if we didn't want 100% of our traffic going to this new revision? Maybe we want to slowly roll users over from our old version to the new version, or do some A/B testing of the new version to see what users prefer. Let's update the service to send 10% of the traffic to our new revision ( fib-knative-zero ), and 90% to the old revision ( fib-knative-one ) kn service update fib-knative --traffic fib-knative-zero = 10 --traffic fib-knative-one = 90 Again, we can use kn service describe to see these changes. Notice the Revisions section. You can see that 10% of the traffic will be sent to fib-knative-zero , and 90% of the traffic will be sent to fib-knative-one . kn service describe fib-knative Expected Output: Revisions: 10% fib-knative-zero (current @latest) [2] (58m) Image: docker.io/ibmcom/fib-knative:vnext (pinned to c13569) 90% fib-knative-one [1] (59m) Image: docker.io/ibmcom/fib-knative (pinned to 9eac25) Let's run some load against the app, just requesting the first number in the Fibonacci sequence so that we can clearly see which revision is being called. while sleep 0 .5 ; do curl \" $MY_APP_URL /1\" ; done Expected Output: [1][1][0][1][1][1][1][1][1][1][1] We should see that the curl requests are routed approximately 90/10 between the two revisions. Let's kill this process using ctrl + c . Congratulations! You've deployed two versions of the fib-knative application, and then updated the rollout percentage of your application.","title":"Deploy vnext"},{"location":"lab3/","text":"Tag revisions to generate custom app URLs \u00b6 What if we wanted to create URLs that are specific for each of the two revisions we created earlier? Maybe one of the revisions is for staging, and one is for production. You can automatically create a URL for a specific revision by using the --tag option. Tag revisions \u00b6 Let's tag both of our revisions. We'll tag fib-knative-zero as zero , and fib-knative-one as one . kn service update fib-knative --tag fib-knative-zero=zero --tag fib-knative-one=one When we tagged the revisions, Knative should have created two new URLs, one for each of the revisions. The new URLs will be the same format as your old URL, but with zero- or one- prepended before the service name in the URL. Let's get the old URL now, and then build the new URLs. echo $MY_APP_URL Your old URL will look something like this: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Add zero- or one- before the service name to get your new URLs, and then save these as environment variables. The new URLs will look something like this: export ZERO_URL = http://zero-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud export ONE_URL = http://one-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Let's try out our URLs to confirm that we're getting the expected results! Try the URL for version 1 of the app: curl $ZERO_URL /4 Example output: [0,1,1,2] Try the URL for version 2 of the app: curl $ONE_URL /4 Example output: [1,1,2,3] Congratulations! You've tagged each revision of your fib-knative application resulting in customized URLs for each version of our application.","title":"Tag revisions to generate custom app URLs"},{"location":"lab3/#tag-revisions-to-generate-custom-app-urls","text":"What if we wanted to create URLs that are specific for each of the two revisions we created earlier? Maybe one of the revisions is for staging, and one is for production. You can automatically create a URL for a specific revision by using the --tag option.","title":"Tag revisions to generate custom app URLs"},{"location":"lab3/#tag-revisions","text":"Let's tag both of our revisions. We'll tag fib-knative-zero as zero , and fib-knative-one as one . kn service update fib-knative --tag fib-knative-zero=zero --tag fib-knative-one=one When we tagged the revisions, Knative should have created two new URLs, one for each of the revisions. The new URLs will be the same format as your old URL, but with zero- or one- prepended before the service name in the URL. Let's get the old URL now, and then build the new URLs. echo $MY_APP_URL Your old URL will look something like this: http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Add zero- or one- before the service name to get your new URLs, and then save these as environment variables. The new URLs will look something like this: export ZERO_URL = http://zero-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud export ONE_URL = http://one-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud Let's try out our URLs to confirm that we're getting the expected results! Try the URL for version 1 of the app: curl $ZERO_URL /4 Example output: [0,1,1,2] Try the URL for version 2 of the app: curl $ONE_URL /4 Example output: [1,1,2,3] Congratulations! You've tagged each revision of your fib-knative application resulting in customized URLs for each version of our application.","title":"Tag revisions"},{"location":"lab4/","text":"Knative from the Kubernetes Layer \u00b6 Up until this point, we've used the Knative CLI, kn , to deploy, update, and interact with our application. While our application is running on Kubernetes, we haven't had to interact with any of the underlying Kubernetes components. If we did want to control or view the application at this layer of the stack, we certainly could. Knative defines some objects for each component as Kubernetes Custom Resource Definitions (CRDs). A CRD is used to define a new resource type in Kubernetes. Knative Serving includes a number of Custom Resource Definitions, including Service, Route, Configuration, and Revision. Because Knative is built on top of Kubernetes, we can access all of these resource types from the Kubernetes layer in the stack. Explore Application Deployment Using oc \u00b6 Our application may have already scaled down to zero. Let's curl the application, and then view the pods our application is running on. curl $MY_APP_URL /4 oc get pods --watch You should see some pods to indicate that your application is running. You may see pods for both versions of your application (-zero and -one). Wait about 90 seconds, and you should see that your application scales back down to zero and the pods terminate due to lack of use. You should eventually see the pods move from the Running to the Terminating state. Example Output: NAME READY STATUS RESTARTS AGE fib-knative-one-deployment-79d6cb9cbd-v4th5 2/2 Running 0 43s fib-knative-zero-deployment-968c8896-8mhkx 2/2 Running 0 60s fib-knative-one-deployment-79d6cb9cbd-v4th5 2/2 Terminating 0 86s fib-knative-one-deployment-79d6cb9cbd-v4th5 0/2 Terminating 0 96s fib-knative-zero-deployment-968c8896-8mhkx 0/2 Terminating 0 96s Note: To exit the watch, use ctrl + c . We can also view some details about the Configuration for our Service. Every Service has a Configuration and a Route -- each time a Configuration is updated, a new Revision is created. Let's see a list of Configurations, first. oc get configuration Example Output: NAME LATESTCREATED LATESTREADY READY REASON fib-knative fib-knative-zero fib-knative-zero True Next, let's see some of the details of the fib-knative Configuration. oc get configuration fib-knative --output yaml Example Output: apiVersion : serving.knative.dev/v1 kind : Configuration metadata : annotations : serving.knative.dev/creator : IAM#beemarie@us.ibm.com serving.knative.dev/lastModifier : IAM#beemarie@us.ibm.com creationTimestamp : \"2020-05-18T18:21:10Z\" generation : 3 labels : serving.knative.dev/route : fib-knative serving.knative.dev/service : fib-knative name : fib-knative namespace : default ownerReferences : - apiVersion : serving.knative.dev/v1alpha1 blockOwnerDeletion : true controller : true kind : Service name : fib-knative uid : 8fb26d78-1e95-4140-9a11-d0ca288011e7 resourceVersion : \"1123399\" selfLink : /apis/serving.knative.dev/v1/namespaces/default/configurations/fib-knative uid : d4e043ac-439c-4dc4-90e5-e71d88d1b4ea spec : template : metadata : annotations : client.knative.dev/user-image : docker.io/ibmcom/fib-knative:vnext creationTimestamp : null name : fib-knative-zero spec : containerConcurrency : 0 containers : - image : docker.io/ibmcom/fib-knative:vnext name : user-container readinessProbe : successThreshold : 1 tcpSocket : port : 0 resources : {} timeoutSeconds : 300 status : conditions : - lastTransitionTime : \"2020-05-18T18:38:33Z\" status : \"True\" type : Ready latestCreatedRevisionName : fib-knative-zero latestReadyRevisionName : fib-knative-zero observedGeneration : 3 The Configuration shows the desired state for our application. You can see the image that our Service is using, as well as the namespace the Service is in, the status of the Service, and some other configuration information. When creating your Service, some other objects were created in Kubernetes as well, such as Routes or Revisions. Let's check out the Route. oc get routes.serving.knative.dev fib-knative -o yaml Example Output: ... traffic : - latestRevision : false percent : 10 revisionName : fib-knative-zero tag : zero url : http://zero-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud - latestRevision : false percent : 90 revisionName : fib-knative-one tag : one url : http://one-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud url : http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud In the traffic section you can see the two URLs that were created when we tagged the revisions, as well as the percentage of traffic going to each Revision. We can also see a list of Revisions created in Kubernetes: oc get revision Example Output: NAME CONFIG NAME K8S SERVICE NAME GENERATION READY REASON fib-knative-one fib-knative fib-knative-one 2 True fib-knative-ywvgm-1 fib-knative fib-knative-ywvgm-1 1 True fib-knative-zero fib-knative fib-knative-zero 3 True This is the end of the serverless lab so let's clean up our service. kn service delete fib-knative Congratulations! You have had a quick overview of deploying applications to Knative using the kn CLI as well as using oc to do some advanced debugging and exploration.","title":"Knative from the Kubernetes Layer"},{"location":"lab4/#knative-from-the-kubernetes-layer","text":"Up until this point, we've used the Knative CLI, kn , to deploy, update, and interact with our application. While our application is running on Kubernetes, we haven't had to interact with any of the underlying Kubernetes components. If we did want to control or view the application at this layer of the stack, we certainly could. Knative defines some objects for each component as Kubernetes Custom Resource Definitions (CRDs). A CRD is used to define a new resource type in Kubernetes. Knative Serving includes a number of Custom Resource Definitions, including Service, Route, Configuration, and Revision. Because Knative is built on top of Kubernetes, we can access all of these resource types from the Kubernetes layer in the stack.","title":"Knative from the Kubernetes Layer"},{"location":"lab4/#explore-application-deployment-using-oc","text":"Our application may have already scaled down to zero. Let's curl the application, and then view the pods our application is running on. curl $MY_APP_URL /4 oc get pods --watch You should see some pods to indicate that your application is running. You may see pods for both versions of your application (-zero and -one). Wait about 90 seconds, and you should see that your application scales back down to zero and the pods terminate due to lack of use. You should eventually see the pods move from the Running to the Terminating state. Example Output: NAME READY STATUS RESTARTS AGE fib-knative-one-deployment-79d6cb9cbd-v4th5 2/2 Running 0 43s fib-knative-zero-deployment-968c8896-8mhkx 2/2 Running 0 60s fib-knative-one-deployment-79d6cb9cbd-v4th5 2/2 Terminating 0 86s fib-knative-one-deployment-79d6cb9cbd-v4th5 0/2 Terminating 0 96s fib-knative-zero-deployment-968c8896-8mhkx 0/2 Terminating 0 96s Note: To exit the watch, use ctrl + c . We can also view some details about the Configuration for our Service. Every Service has a Configuration and a Route -- each time a Configuration is updated, a new Revision is created. Let's see a list of Configurations, first. oc get configuration Example Output: NAME LATESTCREATED LATESTREADY READY REASON fib-knative fib-knative-zero fib-knative-zero True Next, let's see some of the details of the fib-knative Configuration. oc get configuration fib-knative --output yaml Example Output: apiVersion : serving.knative.dev/v1 kind : Configuration metadata : annotations : serving.knative.dev/creator : IAM#beemarie@us.ibm.com serving.knative.dev/lastModifier : IAM#beemarie@us.ibm.com creationTimestamp : \"2020-05-18T18:21:10Z\" generation : 3 labels : serving.knative.dev/route : fib-knative serving.knative.dev/service : fib-knative name : fib-knative namespace : default ownerReferences : - apiVersion : serving.knative.dev/v1alpha1 blockOwnerDeletion : true controller : true kind : Service name : fib-knative uid : 8fb26d78-1e95-4140-9a11-d0ca288011e7 resourceVersion : \"1123399\" selfLink : /apis/serving.knative.dev/v1/namespaces/default/configurations/fib-knative uid : d4e043ac-439c-4dc4-90e5-e71d88d1b4ea spec : template : metadata : annotations : client.knative.dev/user-image : docker.io/ibmcom/fib-knative:vnext creationTimestamp : null name : fib-knative-zero spec : containerConcurrency : 0 containers : - image : docker.io/ibmcom/fib-knative:vnext name : user-container readinessProbe : successThreshold : 1 tcpSocket : port : 0 resources : {} timeoutSeconds : 300 status : conditions : - lastTransitionTime : \"2020-05-18T18:38:33Z\" status : \"True\" type : Ready latestCreatedRevisionName : fib-knative-zero latestReadyRevisionName : fib-knative-zero observedGeneration : 3 The Configuration shows the desired state for our application. You can see the image that our Service is using, as well as the namespace the Service is in, the status of the Service, and some other configuration information. When creating your Service, some other objects were created in Kubernetes as well, such as Routes or Revisions. Let's check out the Route. oc get routes.serving.knative.dev fib-knative -o yaml Example Output: ... traffic : - latestRevision : false percent : 10 revisionName : fib-knative-zero tag : zero url : http://zero-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud - latestRevision : false percent : 90 revisionName : fib-knative-one tag : one url : http://one-fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud url : http://fib-knative-default.bmv-dev-16-5290c8c8e5797924dc1ad5d1b85b37c0-0000.us-south.containers.appdomain.cloud In the traffic section you can see the two URLs that were created when we tagged the revisions, as well as the percentage of traffic going to each Revision. We can also see a list of Revisions created in Kubernetes: oc get revision Example Output: NAME CONFIG NAME K8S SERVICE NAME GENERATION READY REASON fib-knative-one fib-knative fib-knative-one 2 True fib-knative-ywvgm-1 fib-knative fib-knative-ywvgm-1 1 True fib-knative-zero fib-knative fib-knative-zero 3 True This is the end of the serverless lab so let's clean up our service. kn service delete fib-knative Congratulations! You have had a quick overview of deploying applications to Knative using the kn CLI as well as using oc to do some advanced debugging and exploration.","title":"Explore Application Deployment Using oc"},{"location":"setup/","text":"Setup \u00b6 Access the assigned cluster via the IBM Cloud Shell web terminal \u00b6 In a separate browser tab go to the OpenShift console of the cluster assigned to you. Click on your username in the upper right and select Copy Login Command Click the Display Token link. Copy the contents of the field Log in with this token to the clipboard. It provides a login command with a valid token for your username. In a separate browser tab go to the IBM Cloud URL https://cloud.ibm.com and log in with your ibm.com credentials. Click the icon for the IBM Cloud Shell terminal to launch it Paste the oc login command in the IBM Cloud Shell terminal and run it Create an OpenShift project for the labs \u00b6 Run the following command to create a project for the labs oc new-project knlabs","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#access-the-assigned-cluster-via-the-ibm-cloud-shell-web-terminal","text":"In a separate browser tab go to the OpenShift console of the cluster assigned to you. Click on your username in the upper right and select Copy Login Command Click the Display Token link. Copy the contents of the field Log in with this token to the clipboard. It provides a login command with a valid token for your username. In a separate browser tab go to the IBM Cloud URL https://cloud.ibm.com and log in with your ibm.com credentials. Click the icon for the IBM Cloud Shell terminal to launch it Paste the oc login command in the IBM Cloud Shell terminal and run it","title":"Access the assigned cluster via the IBM Cloud Shell web terminal"},{"location":"setup/#create-an-openshift-project-for-the-labs","text":"Run the following command to create a project for the labs oc new-project knlabs","title":"Create an OpenShift project for the labs"}]}